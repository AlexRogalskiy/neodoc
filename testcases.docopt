# vim: set ft=python:
r"""Usage: prog

"""
$ prog
{}

$ prog --xxx
"user-error"


r"""Usage: prog [options]

Options: -a  All.

"""
$ prog
{}

$ prog -a
{"-a": true}

$ prog -x
"user-error"


r"""Usage: prog [options]

Options: --all  All.

"""
$ prog
{}

$ prog --all
{"--all": true}

$ prog --xxx
"user-error"


r"""Usage: prog [options]

Options: -v, --verbose  Verbose.

"""
$ prog --verbose
{"--verbose": true, "-v": true}

$ prog -v
{"--verbose": true, "-v": true}


r"""Usage: prog [options]

Options: -p PATH

"""
$ prog -p home/
{"-p": "home/"}

$ prog -phome/
{"-p": "home/"}

$ prog -p
"user-error"


r"""Usage: prog [options]

Options: --path <path>

"""
$ prog --path home/
{"--path": "home/"}

$ prog --path=home/
{"--path": "home/"}

$ prog --path
"user-error"


r"""Usage: prog [options]

Options: -p PATH, --path=<path>  Path to files.

"""
$ prog -proot
{"--path": "root", "-p": "root"}

r"""Usage: prog [options]

Options:    -p --path PATH  Path to files.

"""
$ prog -p root
{"--path": "root", "-p": "root"}

$ prog --path root
{"--path": "root", "-p": "root"}


r"""Usage: prog [options]

Options:
 -p PATH  Path to files [default: ./]

"""
$ prog
{"-p": "./"}

$ prog -phome
{"-p": "home"}


r"""UsAgE: prog [options]

OpTiOnS: --path=<files>  Path to files
                [dEfAuLt: /root]

"""
$ prog
{"--path": "/root"}

$ prog --path=home
{"--path": "home"}


r"""usage: prog [options]

options:
    -a        Add
    -r        Remote
    -m <msg>  Message

"""

$ prog -a -r
{"-a": true,
 "-r": true}

$ prog -a -r -m Hello
{"-a": true,
 "-m": "Hello",
 "-r": true}

$ prog -armyourass
{"-a": true,
 "-m": "yourass",
 "-r": true}


r"""Usage: prog [options]

Options: --vertical
         --verbose

"""
$ prog --vertical
{"--vertical": true}

$ prog --verbose
{"--verbose": true}


r"""usage: prog [-a -r -m <msg>]

options:
 -a        Add
 -r        Remote
 -m <msg>  Message

"""
$ prog -armyourass
{"-a": true,
 "-m": "yourass",
 "-r": true}


r"""usage: prog [-armmsg]

options: -a        Add
         -r        Remote
         -m <msg>  Message

"""
$ prog -a -r -m Hello
{"-a": true,
 "-m": "Hello",
 "-r": true}

$ prog -ar -m Hello
{"-a": true,
 "-m": "Hello",
 "-r": true}

$ prog -arm Hello
{"-a": true,
 "-m": "Hello",
 "-r": true}

$ prog -armHello
{"-a": true,
 "-m": "Hello",
 "-r": true}

$ prog -arm=Hello
{"-a": true,
 "-m": "Hello",
 "-r": true}

$ prog -m=Hello
{"-m": "Hello"}

$ prog -m Hello
{"-m": "Hello"}

$ prog -mHello
{"-m": "Hello"}

$ prog -m
"user-error"

r"""usage: prog [-arm=msg]

options: -a        Add
         -r        Remote
         -m <msg>  Message

"""
$ prog -a -r -m Hello
{"-a": true,
 "-m": "Hello",
 "-r": true}

$ prog -ar -m Hello
{"-a": true,
 "-m": "Hello",
 "-r": true}

$ prog -arm Hello
{"-a": true,
 "-m": "Hello",
 "-r": true}

$ prog -armHello
{"-a": true,
 "-m": "Hello",
 "-r": true}

$ prog -arm=Hello
{"-a": true,
 "-m": "Hello",
 "-r": true}

$ prog -m=Hello
{"-m": "Hello"}

$ prog -m Hello
{"-m": "Hello"}

$ prog -mHello
{"-m": "Hello"}

$ prog -m
"user-error"

r"""usage: prog -a -b

options:
 -a
 -b

"""
$ prog -a -b
{"-a": true, "-b": true}

$ prog -b -a
{"-a": true, "-b": true}

$ prog -ab
{"-a": true, "-b": true}

$ prog -ba
{"-a": true, "-b": true}

$ prog -a
{"-a": true}

$ prog
{}


r"""usage: prog (-a -b)

options: -a
         -b

"""
$ prog -a -b
{"-a": true, "-b": true}

$ prog -b -a
{"-a": true, "-b": true}

$ prog -ab
{"-a": true, "-b": true}

$ prog -ba
{"-a": true, "-b": true}

$ prog -a
{"-a": true}

$ prog
{}


r"""usage: prog [-a] -b

options: -a
 -b

"""
$ prog -a -b
{"-a": true, "-b": true}

$ prog -b -a
{"-a": true, "-b": true}

$ prog -a
{"-a": true}

$ prog -b
{"-b": true}

$ prog
{}


r"""usage: prog [(-a -b)]

options: -a
         -b

"""
$ prog -a -b
{"-a": true, "-b": true}

$ prog -b -a
{"-a": true, "-b": true}

$ prog -ab
{"-a": true, "-b": true}

$ prog -ba
{"-a": true, "-b": true}

$ prog -a
{"-a": true}

$ prog -b
{"-b": true}

$ prog
{}


#
# Mutually excluse groups
#

r"""usage: prog (-a|-b)"""
$ prog -a -b
"user-error"

$ prog
{}

$ prog -a
{"-a": true}

$ prog -b
{"-b": true}


r"""usage: prog [ -a | -b ]

options: -a
         -b

"""
$ prog -a -b
"user-error"

$ prog
{}

$ prog -a
{"-a": true}

$ prog -b
{"-b": true}


r"""usage: prog <arg>"""
$ prog 10
{"<arg>": 10}

$ prog 10 20
"user-error"

$ prog
"user-error"


r"""usage: prog [<arg>]"""
$ prog 10
{"<arg>": 10}

$ prog 10 20
"user-error"

$ prog
{}


r"""usage: prog <kind> <name> <type>"""
$ prog 10 20 40
{"<kind>": 10, "<name>": 20, "<type>": 40}

$ prog 10 20
"user-error"

$ prog
"user-error"


r"""usage: prog <kind> [<name> <type>]"""
$ prog 10 20 40
{"<kind>": 10, "<name>": 20, "<type>": 40}

$ prog 10 20
# Original: {"<kind>": 10, "<name>": 20}
"user-error"

$ prog
"user-error"


r"""usage: prog [<kind> | <name> <type>]"""
$ prog 10 20 40
"user-error"

$ prog 20 40
{"<name>": 20, "<type>": 40}

$ prog
{}


r"""usage: prog (<kind> --all | <name>)

options:
 --all

"""
$ prog 10 --all
{"--all": true, "<kind>": 10}

$ prog 10
{"<kind>": 10}

$ prog
"user-error"


r"""usage: prog [<name> <name>]"""
$ prog 10 20
{"<name>": [10, 20]}

# Note: This is a deviation. The spec above says that
#       it wants exactly *two* occurences of `<name>`.
#       hence we shall give it that and if not -error.
#       See the added test below for how to do it in
#       this implementation.
# Original:
# {"<name>": [10], "NAME": [10]}
$ prog 10
"user-error"

$ prog
{}

# Added test case:
# (See note above)
r"""usage: prog [<name> [<name>]]"""
$ prog 10 20
{"<name>": [10, 20]}

$ prog 10
{"<name>": [10]}

$ prog
{}


r"""usage: prog [(<name> <name>)]"""
$ prog 10 20
{"<name>": [10, 20]}

$ prog 10
"user-error"

$ prog
{}

r"""usage: prog NAME..."""
$ prog 10 20
{"NAME": [10, 20]}

$ prog 10
{"NAME": [10]}

$ prog
"user-error"

r"""usage: prog [NAME]..."""
$ prog 10 20
{"NAME": [10, 20]}

$ prog 10
{"NAME": [10]}

$ prog
{}


r"""usage: prog [NAME...]"""
$ prog 10 20
{"NAME": [10, 20]}

$ prog 10
{"NAME": [10]}

$ prog
{}


r"""usage: prog [NAME [NAME ...]]"""
$ prog 10 20
{"NAME": [10, 20]}

$ prog 10
{"NAME": [10]}

$ prog
{}


r"""usage: prog (NAME | --foo NAME)

options: --foo

"""
$ prog 10
{"NAME": 10}

$ prog --foo 10
{"--foo": true, "NAME": 10}

$ prog --foo=10
"user-error"

r"""usage: prog (NAME | --foo) [--bar | NAME]

options: --foo
options: --bar

"""
$ prog 10
{"NAME": [10]}

$ prog 10 20
{"NAME": [10, 20]}

$ prog --foo --bar
{"--bar": true, "--foo": true}


r"""Naval Fate.

Usage:
  prog ship new <name>...
  prog ship [<name>] move <x> <y> [--speed=<kn>]
  prog ship shoot <x> <y>
  prog mine (set|remove) <x> <y> [--moored|--drifting]
  prog -h | --help
  prog --version

Options:
  -h --help     Show this screen.
  --version     Show version.
  --speed=<kn>  Speed in knots [default: 10].
  --moored      Mored (anchored) mine.
  --drifting    Drifting mine.

"""

$ prog ship Guardian move 150 300 --speed=20
{"--speed": 20,
 "<name>": "Guardian",
 "<x>": 150,
 "<y>": 300,
 "move": true,
 "ship": true}


r"""usage: prog --hello"""
$ prog --hello
{"--hello": true}


r"""usage: prog [--hello=<world>]"""
$ prog
{}

$ prog --hello wrld
{"--hello": "wrld"}


r"""usage: prog [-o]"""
$ prog
{}

$ prog -o
{"-o": true}


r"""usage: prog [-opr]"""
$ prog -op
{"-o": true, "-p": true}


r"""usage: prog --aabb | --aa"""
# Original:
# {"--aabb": false, "--aa": true}
$ prog --aa
{"--aa": true}

# Note: This is kept, but fails for other reasons
#       than being a unique prefix: The option
#       simply is not part of the specification.
$ prog --a
"user-error"  # not a unique prefix

#
# Counting number of flags
#

r"""Usage: prog -v"""
$ prog -v
{"-v": true}


r"""Usage: prog [-v -v]"""
$ prog
{}

$ prog -v
{"-v": 1}

$ prog -vv
{"-v": 2}


r"""Usage: prog -v ..."""
# Note: Deviation: We allow not passing flags.
# Original "user-error"
$ prog
{}

$ prog -v
{"-v": 1}

$ prog -vv
{"-v": 2}

$ prog -vvvvvv
{"-v": 6}


r"""Usage: prog [-v | -vv | -vvv]

This one is probably most readable user-friednly variant.

"""
$ prog
{}

$ prog -v
{"-v": 1}

$ prog -vv
{"-v": 2}

$ prog -vvvv
"user-error"


r"""usage: prog [--ver --ver]"""
$ prog --ver --ver
{"--ver": 2}

#
# Counting commands
#

r"""usage: prog [go]"""
$ prog go
{"go": true}


# Note: Deviation: [go go] means both `go` are required!
# Original:
# r"""usage: prog [go go]"""
r"""usage: prog [go [go]]"""
$ prog
{}

$ prog go
{"go": 1}

$ prog go go
{"go": 2}

$ prog go go go
"user-error"

r"""usage: prog go..."""
$ prog go go go go go
{"go": 5}

#
# [options] does not include options from usage-pattern
#

r"""usage: prog [options] [-a]

options: -a
         -b
"""

$ prog -a
{"-a": true}

$ prog -aa
"user-error"

r"""usage: prog [options] [-a]

options: -a, --all
         -b
"""

$ prog -a
{"-a": true, "--all": true}

$ prog --all
{"-a": true, "--all": true}

$ prog -aa
"user-error"

$ prog --all -a
"user-error"

$ prog -a --all
"user-error"

$ prog --all --all
"user-error"

#
# Test [options] shourtcut
#

r"""Usage: prog [options] A
Options:
    -q  Be quiet
    -v  Be verbose.

"""

$ prog arg
{"A": "arg"}

$ prog -v arg
{"-v": true, "A": "arg"}

$ prog -q arg
{"-q": true, "A": "arg"}

#
# Test single dash
#

r"""usage: prog [-]"""

$ prog -
{"-": true}

$ prog
{}

#
# If argument is repeated, its value should always be a list
#

r"""usage: prog [NAME [NAME ...]]"""

$ prog a b
{"NAME": ["a", "b"]}

$ prog
{}

#
# Option's argument defaults to null/None
#
# Note: Deviation: Currently, these values are omitted entirely.
#       XXX: ...this could be revisited
#

r"""usage: prog [options]
options:
 -a        Add
 -m <msg>  Message

"""
$ prog -a
{"-a": true}

#
# Test options without description
#

r"""usage: prog --hello"""
$ prog --hello
{"--hello": true}

r"""usage: prog [--hello=<world>]"""
# Original { "--hello": null }
$ prog
{}

$ prog --hello wrld
{"--hello": "wrld"}

r"""usage: prog [-o]"""
$ prog
{}

$ prog -o
{"-o": true}

r"""usage: prog [-opr]"""
$ prog -op
{"-o": true, "-p": true}

r"""usage: git [-v | --verbose]"""
$ prog -v
{"-v": true}

r"""usage: git remote [-v | --verbose]"""
$ prog remote -v
{"-v": true, "remote": true}

#
# Test empty usage pattern
#

r"""
usage: prog
"""
$ prog
{}

r"""
usage: prog
       prog <a> <b>
"""
$ prog 1 2
{"<a>": 1, "<b>": 2}

# Original: {"<a>": null, "<b>": null}
$ prog
{}

r"""
usage: prog <a> <b>
       prog
"""
# Original: {"<a>": null, "<b>": null}
$ prog
{}

#
# Option's argument should not capture default value from usage pattern
#

r"""usage: prog [--file=<f>]"""
$ prog
{}

r"""usage: prog [--file=<f>]

options: --file <a>

"""
$ prog
{}

r"""
Usage: prog [-a <host:port>]

Options: -a, --address <host:port>  TCP address [default: localhost:6283].

"""

# Note: This implementation will also complete the alias.
# Original: {"--address": "localhost:6283"}
$ prog
{"--address": "localhost:6283",
 "-a": "localhost:6283"}

#
# If option with argument could be repeated,
# its arguments should be accumulated into a list
#

r"""usage: prog --long=<arg> ..."""

$ prog --long one
{"--long": ["one"]}

$ prog --long one --long two
{"--long": ["one", "two"]}


#
# Test multiple elements repeated at once
#

r"""usage: prog (go <direction> --speed=<km/h>)..."""

$ prog  go left --speed=5  go right --speed=9
{"--speed": [5, 9],
 "<direction>": ["left", "right"],
 "go": 2}


#
# If option could be repeated its defaults should be split into a list
#

r"""usage: prog [-o <o>]...

options: -o <o>  [default: x]

"""
$ prog -o this -o that
{"-o": ["this", "that"]}

$ prog
{"-o": ["x"]}

r"""usage: prog [-o <o>]...

options: -o <o>  [default: x y]

"""
$ prog -o this
{"-o": ["this"]}

$ prog
{"-o": ["x", "y"]}

# Note: Added to test defaults escaping
r"""usage: prog [-o <o>]...

options: -o <o>  [default: "x y"]

"""
$ prog -o this
{"-o": ["this"]}

$ prog
{"-o": ["x y"]}

#
# Test stacked option's argument
#

r"""usage: prog -pPATH

options: -p PATH

"""
$ prog -pHOME
{"-p": "HOME"}

#
# Issue 56: Repeated mutually exclusive args give nested lists sometimes
#

r"""Usage: foo (--xx=x|--yy=y)..."""
$ prog --xx=1 --yy=2
{"--xx": [1], "--yy": [2]}

#
# POSIXly correct tokenization
#

r"""usage: prog [<input file>]"""
$ prog f.txt
{"<input file>": "f.txt"}

r"""usage: prog [--input=<file name>]..."""
$ prog --input a.txt --input=b.txt
{"--input": ["a.txt", "b.txt"]}

#
# Issue 85: `[options]` shourtcut with multiple subcommands
#
# Note: The initial line is put onto a newline in order
#       for the second line to line up (otherwise the
#       leading 'r"""' skew the results), since the usage
#       parser is indent-based.
r"""
usage: prog good [options]
       prog fail [options]

options: --loglevel=N

"""
# Original:
# {"--loglevel": 5, "fail": true, "good": false}
$ prog fail --loglevel 5
{"--loglevel": 5, "fail": true}

#
# Usage-section syntax
#

r"""usage:prog --foo"""
$ prog --foo
{"--foo": true}

r"""PROGRAM USAGE: prog --foo"""
$ prog --foo
{"--foo": true}


# Note: The initial line is put onto a newline in order
#       for the second line to line up (otherwise the
#       leading 'r"""' skew the results), since the usage
#       parser is indent-based.
r"""
Usage: prog --foo
       prog --bar
NOT PART OF SECTION"""
$ prog --foo
{"--foo": true}

$ prog --bar
{"--bar": true}

r"""Usage:
 prog --foo
 prog --bar

NOT PART OF SECTION"""
$ prog --foo
{"--foo": true}

$ prog --bar
{"--bar": true}

r"""Usage:
 prog --foo
 prog --bar
NOT PART OF SECTION"""
$ prog --foo
{"--foo": true}

$ prog --bar
{"--bar": true}


#
# Options-section syntax
#

r"""Usage: prog [options]

global options: --foo
local options: --baz
               --bar
other options:
 --egg
 --spam
-not-an-option-

"""
$ prog --baz --egg
{"--baz": true,
 "--egg": true}

#
# README example usage
#

r"""
Naval Fate.

Usage:
  naval_fate ship new <name>...
  naval_fate ship <name> move <x> <y> --speed=<kn>
  naval_fate ship shoot <x> <y>
  naval_fate mine (set|remove) <x> <y> [--moored|--drifting]
  naval_fate -h | --help
  naval_fate --version

Options:
  -h --help     Show this screen.
  --version     Show version.
  --speed=<kn>  Speed in knots [default: 10].
  --moored      Moored (anchored) mine.
  --drifting    Drifting mine.
"""

$ prog ship new foo bar baz
{"<name>": ["foo", "bar", "baz"],
 "new": true,
 "ship": true}

$ prog ship foo move 10 10 --speed
"user-error"

#
# Passing arguments to options
#

r"""Usage: prog --foo"""

$ prog --foo=bar
"user-error"

r"""Usage: prog -f"""

$ prog -f=bar
"user-error"

#
# Allow complex argument names <...>
#

r"""
Usage: prog --foo
Options: -f, --foo
"""

$ prog -f=bar
"user-error"

$ prog --foo=bar
"user-error"

r"""
Usage: prog [-p <n>] [-d <connstring>]
   or: prog syncdb [-p <n>] [-d <connstring>]

common options:
    -p, --port=<n>
        [default: 5000]

    -d, --database=<connstring>
        [default: memory]
"""

$ prog syncdb
{"syncdb": true, "-p": 5000, "--port": 5000,
 "--database": "memory", "-d": "memory"}

#
# Type inference
#

r"""
Usage: prog [options]

Options: -f=<n>  [default: foo , bar qux, "foo bar", 400, true,
                           false, 10.1, TRUE, FALSE, True False,
                           -100, -10.1
                           "True" "True False 10"]
"""

$ prog
{ "-f": ["foo", "bar", "qux", "foo bar", 400, true, false, 10.1,
         true, false, true, false,
         -100, -10.1,
         "True", "True False 10"] }

#
# Valid program names
#

r"""
Usage: prog.js [options]
"""

$ prog
{}

r"""
Usage: create_ec2.py --profile=PROFILE --name=INSTANCE_NAME --instance-type=INSTANCE_TYPE
        --key-name=KEY_NAME
        --ami=AMI_NAME --subnet=SUBNET_NAME
        --iam-instance-profile=IAM_INSTANCE_PROFILE
        [--security-group=SECURITY_GROUP]...
        [--elb=ELB_NAME]...
        [(--tag-name=STRING --tag-value=VALUE)]...
NOT PART OF SECTION

Options:
    -P PROFILE --profile=PROFILE                            profile in which to operate
    -n NAME --name=NAME                                     element name
    -T KEY --tag-name=KEY                                   tag name
    -V VALUE--tag-value=VALUE                               tag value
    -e ELB_NAME --elb=ELB_NAME                              name of ELB to register an instance with
    -a AMI_NAME --ami=AMI_NAME                              name of AMI to install an instance with
    -t TYPE --instance-type=TYPE                            instance type to create instance with
    -k KEY_NAME --key-name=KEY_NAME                         name of key that grants access to instance
    -s SUBNET_NAME --subnet=SUBNET_NAME                      subnet name to create instance in
    -S SG_NAME --security-group=SG_NAME                     security group to set to the instance
    -p PROFILE_NAME --iam-instance-profile=PROFILE_NAME     IAM instance profile to start instance with
Not at
"""

$ prog -ssubnet-0 -asome-ami -ksome-key --instance-type=t2.micro --name=foo -Psome-profile --iam-instance-profile=some-iam-instance-profile
{"-P": "some-profile",
 "--profile": "some-profile",
 "-a": "some-ami",
 "--ami": "some-ami",
 "-p": "some-iam-instance-profile",
 "--iam-instance-profile": "some-iam-instance-profile",
 "-t": "t2.micro",
 "--instance-type": "t2.micro",
 "-k": "some-key",
 "--key-name": "some-key",
 "-n": "foo",
 "--name": "foo",
 "-s": "subnet-0",
 "--subnet": "subnet-0"}

#
# "options-first" enabled
#

r"""
Usage: create_ec2.py -0 ARG ARG...
NOT PART OF SECTION

Options:
    -0, --foo ARG  Do something [default: 100]
"""

$ prog/p foo -0 bar
{"-0": 100, "--foo": 100,
 "ARG": ["foo", "-0", "bar"]}

r"""
Usage: create_ec2.py -0 ARG [ARG]...

Options:
    -0, --foo ARG  Do something [default: 100]
"""

$ prog/p foo -0 bar
{"-0": 100, "--foo": 100,
 "ARG": ["foo", "-0", "bar"]}

r"""
Usage: create_ec2.py -0 ARG [ARG...]

Options:
    -0, --foo ARG  Do something [default: 100]
"""

$ prog/p foo -0 bar
{"-0": 100, "--foo": 100,
 "ARG": ["foo", "-0", "bar"]}

r"""
Usage: create_ec2.py -0 ARG [ARG...]...

Options:
    -0, --foo ARG  Do something [default: 100]
"""

$ prog/p foo -0 bar
{"-0": 100, "--foo": 100,
 "ARG": ["foo", "-0", "bar"]}

$ prog/p foo -0 bar
{"-0": 100, "--foo": 100,
 "ARG": ["foo", "-0", "bar"]}

r"""
Usage: create_ec2.py [ARG...]...

"""

$ prog/p foo bar
{"ARG": ["foo", "bar"]}

#
# "options-first" with [options]
#

r"""
Usage: create_ec2.py (ARG...) [options]

Options:
    -0  This is a zero
"""

$ prog/p foo bar -0
{"ARG": ["foo", "bar", "-0"]}

$ prog/p -0
{"ARG": ["-0"]}

r"""
Usage: create_ec2.py [ARG...] [options]

Options:
    -0  This is a zero
"""

$ prog/p -0
{"ARG": ["-0"]}

$ prog/p foo bar -0
{"ARG": ["foo", "bar", "-0"]}


r"""
Usage: create_ec2.py ARG... [options]

Options:
    -0  This is a zero
    -1  This is a one
"""

$ prog -0
"user-error"

# XXX: this returns superflous "-0" and "-1" in the output:
$ prog/p -01
{"ARG": ["-01"]}

#
# Options-first fix for issue #21
#

r"""
Usage: foo [[<args>...]]
"""

$ prog/p
{"<args>": []}

$ prog/p bar -a -b -c
{"<args>": ["bar", "-a", "-b", "-c"]}

r"""
Usage: foo [<command> [<args>...]]
"""

$ prog/p
{}

$ prog/p bar -a -b -c
{"<command>": "bar",
 "<args>": ["-a", "-b", "-c"]}

#
# Optional arguments
#

r"""
Usage: manage.py --foo[=BAR]
"""

$ prog
{}

$ prog --foo
{"--foo": true}

$ prog --foo bar
{"--foo": "bar"}

$ prog --foo --foo
"user-error"

r"""
Usage: manage.py --foo[=BAR]...
"""

$ prog
{}

$ prog --foo
{"--foo": [true]}

$ prog --foo bar
{"--foo": ["bar"]}

$ prog --foo --foo
{"--foo": [true, true]}

r"""
Usage: manage.py --foo --foo[=BAR]
"""

$ prog
{}

$ prog --foo
{"--foo": [true]}

$ prog --foo bar
"user-error" # "bar" will be considered trailing since the first appearance
             # of '--foo' does not take an argument. XXX: Is this intutive
             # enough?

$ prog --foo --foo=bar
{"--foo": [true, "bar"]}

$ prog --foo --foobar
{"--foo": [true, "bar"]}

$ prog --foo --foo bar
{"--foo": [true, "bar"]}

$ prog --foo --foo
{"--foo": [true, true]}

r"""
Usage: manage.py --foo --foo[=BAR]...
"""

$ prog
{}

$ prog --foo
{"--foo": [true]}

$ prog --foo bar
"user-error" # "bar" will be considered trailing since the first appearance
             # of '--foo' does not take an argument. XXX: Is this intutive
             # enough?

$ prog --foo --foo
{"--foo": [true, true]}

r"""
Usage: manage.py --foo (--foo[=BAR]...)
"""

$ prog
{}

$ prog --foo
{"--foo": [true]}

r"""
Usage: manage.py --foo (--foo[=BAR]...) (--foo[=BAR]...) (--foo[=BAR]...)
"""

$ prog
{}

$ prog --foo
{"--foo": [true]}

r"""
Usage: manage.py --foo (--foo[=BAR]... (--foo[=BAR]...)) (--foo[=BAR]...)
"""

$ prog
{}

$ prog --foo
{"--foo": [true]}

$ prog --foo bar
"user-error" # "bar" will be considered trailing since the first appearance
             # of '--foo' does not take an argument. XXX: Is this intutive
             # enough?

$ prog --foo --foo
{"--foo": [true, true]}

r"""
Usage: manage.py [-f...]... [--foo[=BAR]...]...

Options:
    -f --foo  Blah
"""

$ prog
{}

$ prog --foo
{"--foo": [true], "-f": [true]}

$ prog --foo bar
"user-error" # "bar" will be considered trailing since the first appearance
             # of '--foo' does not take an argument. XXX: Is this intutive
             # enough?

$ prog --foo --foo
{"--foo": [true, true], "-f": [true, true]}

r"""
Usage: manage.py [options]
options: --foo [BAR]
"""

$ prog --foo bar
{"--foo": "bar"}

$ prog
{}

$ prog --foo
{"--foo": true}

$ prog --foo --foo
"user-error"

r"""
Usage: manage.py [options]
options: -f [BAR]
"""

$ prog -f bar
{"-f": "bar"}

$ prog
{}

$ prog -f
{"-f": true}

$ prog -f -f
"user-error"

r"""
Usage: manage.py [options]
options: --foo[BAR]
"""

$ prog --foo bar
{"--foo": "bar"}

$ prog
{}

$ prog --foo
{"--foo": true}

$ prog --foo --foo
"user-error"

r"""
Usage: manage.py [options]
options: -f[BAR]
"""

$ prog -f bar
{"-f": "bar"}

$ prog
{}

$ prog -f
{"-f": true}

$ prog -f -f
"user-error"


r"""
Usage: manage.py [options]
options: --foo[=BAR]
"""

$ prog --foo bar
{"--foo": "bar"}

$ prog
{}

$ prog --foo
{"--foo": true}

$ prog --foo --foo
"user-error"

r"""
Usage: manage.py [options]
options: -f[=BAR]
"""

$ prog -f bar
{"-f": "bar"}

$ prog
{}

$ prog -f
{"-f": true}

$ prog -f -f
"user-error"


#
# Options should be parsed in any order
#

r"""usage: prog [-a] -b"""

$ prog -a -b
{"-a": true, "-b": true}

$ prog -b -a
{"-a": true, "-b": true}

r"""usage: prog -a [-b]"""

$ prog -a -b
{"-a": true, "-b": true}

$ prog -b -a
{"-a": true, "-b": true}

r"""usage: prog -a [-b] -c"""

$ prog -a -b -c
{"-a": true, "-b": true, "-c": true}

$ prog -a -c -b
{"-a": true, "-b": true, "-c": true}

$ prog -b -a -c
{"-a": true, "-b": true, "-c": true}

$ prog -b -c -a
{"-a": true, "-b": true, "-c": true}

$ prog -c -b -a
{"-a": true, "-b": true, "-c": true}

$ prog -c -a -b
{"-a": true, "-b": true, "-c": true}

r"""usage: prog -a [-b -d] -c"""

$ prog -a -b -c
{"-a": true, "-b": true, "-c": true}

$ prog -abc
{"-a": true, "-b": true, "-c": true}

$ prog -a -c -b
{"-a": true, "-b": true, "-c": true}

$ prog -acb
{"-a": true, "-b": true, "-c": true}

$ prog -b -a -c
{"-a": true, "-b": true, "-c": true}

$ prog -bac
{"-a": true, "-b": true, "-c": true}

$ prog -b -c -a
{"-a": true, "-b": true, "-c": true}

$ prog -bca
{"-a": true, "-b": true, "-c": true}

$ prog -c -b -a
{"-a": true, "-b": true, "-c": true}

$ prog -cba
{"-a": true, "-b": true, "-c": true}

$ prog -c -a -b
{"-a": true, "-b": true, "-c": true}

$ prog -cab
{"-a": true, "-b": true, "-c": true}

$ prog -d -a -b -c
"user-error" # -b and -d must appear together

$ prog -a -d -c -b
"user-error" # -b and -d must appear together

$ prog -b -a -d -c
"user-error" # -b and -d must appear together

$ prog -b -c -a -d
"user-error" # -b and -d must appear together


r"""usage: prog [(-a -b)]"""

$ prog -a -b
{"-a": true, "-b": true}

$ prog -b -a
{"-a": true, "-b": true}

$ prog -ab
{"-a": true, "-b": true}

$ prog -ba
{"-a": true, "-b": true}

$ prog -a
{"-a": true}

$ prog -b
{"-b": true}

$ prog
{}

r"""usage: prog [(-a[=BAR] -b)]"""

$ prog -a FOO -b
{"-a": "FOO", "-b": true}

$ prog -b -a FOO
{"-a": "FOO", "-b": true}

$ prog -ab
{"-a": "b"}

$ prog -ba
{"-a": true, "-b": true}

$ prog -a
{"-a": true}

$ prog -b
{"-b": true}

$ prog
{}


r"""usage: prog -a (--foo|--no-foo) -b"""

# $ prog -b -a --foo
# {"-a": true, "-b": true, "--foo": true}

$ prog -b --no-foo -a
{"-a": true, "-b": true, "--foo": false}

$ prog -b --no-foo -a --foo
"user-error"

#
# Issue no. 13
#

r"""
Usage: prog --file <x> <a>
Options: --file <y>
"""

$ prog
"spec-error"

r"""
Usage: prog -f <x> <a>
Options: -f <y>
"""

$ prog
"spec-error"

r"""
Usage: prog -f <x> <a>
Options: -f, --file <y>
"""

$ prog
"spec-error"

r"""
Usage: prog -f <x> <a>
Options: -f <y>, --file <y>
"""

$ prog
"spec-error"

r"""
Usage: prog -f <x> <a>
Options: -f <x>, --file <y>
"""

$ prog
"spec-error"

# This should fail because the `--input` in the usage section does not mention
# the option-argument specified in the options section.

r"""
Usage: prog --input
Options: --input <y>
"""

$ prog
"spec-error"

# This should fail because the `--input` in the usage section does not mention
# the option-argument specified in the options section.

r"""
Usage: prog -f
Options: -f <y>
"""

$ prog
"spec-error"

# This should fail -f cannot take an argument, since it's stacked.

r"""
Usage: prog -fb
Options: -f <y>
"""

$ prog
"spec-error"

#
# Ensure explicit args don't consume adjacent args
#

r"""
Usage: prog --input=<x> <x>
Options: -i <x>, --input <x>
"""

$ prog --input10
"user-error"

$ prog --input 10
"user-error"

$ prog --input 10 20
{ "-i": 10, "--input": 10, "<x>": 20}

#
# Repeating parameterised options
# Example for issue #16
#

r"""
Usage:
    foobar [-f X ... | --foo X ...]
Options:
    -f X, --foo X     bar
"""

$ prog -f 1 -f 2 -f 3 -f 4 -f 5 -f 6
{"--foo": [1, 2, 3, 4, 5, 6],
 "-f": [1, 2, 3, 4, 5, 6]}

$ prog -f 1,2,3,4,5,6
{"--foo": ["1,2,3,4,5,6"],
 "-f": ["1,2,3,4,5,6"]}

$ prog -f 1,2,3 --foo 4,5,6
{"--foo": ["1,2,3", "4,5,6"],
 "-f": ["1,2,3", "4,5,6"]}

$ prog -f 1,2 --foo 3,4 -f 5,6
{"--foo": ["1,2", "3,4", "5,6"],
 "-f": ["1,2", "3,4", "5,6"]}

r"""
Usage:
    foobar [-f X ...] [--foo X ...]
Options:
    -f X, --foo X    bar.
"""

$ prog -f 1 -f 2 -f 3 -f 4 -f 5 -f 6
{"--foo": [1, 2, 3, 4, 5, 6],
 "-f": [1, 2, 3, 4, 5, 6]}

$ prog -f 1,2,3,4,5,6
{"--foo": ["1,2,3,4,5,6"],
 "-f": ["1,2,3,4,5,6"]}

$ prog -f 1,2,3 --foo 4,5,6
{"--foo": ["1,2,3", "4,5,6"],
 "-f": ["1,2,3", "4,5,6"]}

$ prog -f 1,2 --foo 3,4 -f 5,6
{"--foo": ["1,2", "3,4", "5,6"],
 "-f": ["1,2", "3,4", "5,6"]}

#
# Issue #11
#

r"""
Usage:
    git (<y>... | <x> ...)
"""

$ prog a b c
{"<y>": ["a", "b", "c"]}

r"""
Usage:
    git (<x>... | <y> ...)
"""

$ prog a b c
{"<x>": ["a", "b", "c"]}

r"""
Usage:
    git (<y>...|<x>)
"""

$ prog a b c
{"<y>": ["a", "b", "c"]}

r"""
Usage:
    git (<y>...|<y>)
"""

$ prog a b c
{"<y>": ["a", "b", "c"]}

r"""
Usage:
    git (<y>|<x>...)
"""

$ prog a b c
{"<x>": ["a", "b", "c"]}

r"""
Usage:
    git (<x>...|<x>)
"""

$ prog a b c
{"<x>": ["a", "b", "c"]}

#
# Issue #5
# Indicate repeatbility in option descriptions
#

r"""
Usage: foo [options]
Options: -v, --verbose
"""

$ prog
{}

$ prog -v
{"-v": true, "--verbose": true}

$ prog -vv
"user-error"

r"""
Usage: foo [options]
Options: -v, --verbose...
"""

$ prog
{}

$ prog -v
{"-v": 1, "--verbose": 1}

$ prog -vv
{"-v": 2, "--verbose": 2}

r"""
Usage: foo [options]
Options: -v..., --verbose
"""

$ prog
{}

$ prog -v
{"-v": 1, "--verbose": 1}

$ prog -vv
{"-v": 2, "--verbose": 2}

r"""
Usage: foo [options]
Options: -v..., --verbose...
"""

$ prog
{}

$ prog -v
{"-v": 1, "--verbose": 1}

$ prog -vv
{"-v": 2, "--verbose": 2}

#
# Issue #7 - De-dupe [options] upon inlining
#

r"""
Usage: foo -x [options]
Options: -x
"""

$ prog
{}

$ prog -x
{"-x": true}

$ prog -x -x
"user-error"

r"""
Usage: foo -x [options] -x
Options: -x
"""

$ prog
{}

$ prog -x
{"-x": 1}

$ prog -x -x
{"-x": 2}

r"""
Usage: foo --input [options]
Options: --input
"""

$ prog
{}

$ prog --input
{"--input": true}

$ prog --input --input
"user-error"

r"""
Usage: foo --input [options]
Options: -i, --input
"""

$ prog
{}

$ prog -i
{"-i": true, "--input": true}

$ prog -i -i
"user-error"

#
# Smart-flags
# Issue #12
#

r"""
Usage: foo [-i ARG]
"""

$ prog/s
{}

$ prog/s -i 123
{"-i": 123}

$ prog/s -i
"user-error"

r"""
Usage: foo [-i [ARG]]
"""

$ prog/s
{}

$ prog/s -i 123
{"-i": 123}

$ prog/s -i
{"-i": true}

r"""
Usage: foo (-i ARG)
"""

$ prog/s
"user-error"

$ prog/s -i 123
{"-i": 123}

$ prog/s -i
"user-error"

r"""
Usage: foo [-i ARG]...
"""

$ prog/s
{}

$ prog/s -i 123
{"-i": [123]}

$ prog/s -i 123 -i 123
{"-i": [123, 123]}

$ prog/s -i
"user-error"

r"""
Usage: foo [-i ARG...]
"""

$ prog/s
{}

$ prog/s -i 123
{"-i": [123]}

$ prog/s -i 123 -i 123
{"-i": [123, 123]}

$ prog/s -i
"user-error"

r"""
Usage: foo [-i ARG...]...
"""

$ prog/s
{}

$ prog/s -i 123
{"-i": [123]}

$ prog/s -i 123 -i 123
{"-i": [123, 123]}

$ prog/s -i
"user-error"

#
# Smart-flags
# Issue #12
#

r"""
Usage: foo [-oi ARG]
"""

$ prog/s
{}

$ prog/s -i 123
{"-i": 123}

$ prog/s -i
"user-error"

r"""
Usage: foo [-oi [ARG]]
"""

$ prog/s
{}

$ prog/s -i 123
{"-i": 123}

$ prog/s -i
{"-i": true}

r"""
Usage: foo (-oi ARG)
"""

$ prog/s
"user-error"

$ prog/s -i 123
{"-i": 123}

$ prog/s -i
"option requires argument: -i"

r"""
Usage: foo [-oi ARG]...
"""

$ prog/s
{}

$ prog/s -i 123
{"-i": [123]}

$ prog/s -i 123 -i 123
{"-i": [123, 123]}

$ prog/s -i
"user-error"

r"""
Usage: foo [-oi ARG...]
"""

$ prog/s
{}

$ prog/s -i 123
{"-i": [123]}

$ prog/s -i 123 -i 123
{"-i": [123, 123]}

$ prog/s -i
"user-error"

r"""
Usage: foo [-oi ARG...]...
"""

$ prog/s
{}

$ prog/s -i 123
{"-i": [123]}

$ prog/s -i 123 -o
{"-i": [123], "-o": 1}

$ prog/s -i 123 -o 456
"user-error"

$ prog/s -i 123 -i 123
{"-i": [123, 123]}

$ prog/s -i
"user-error"

#
# Environment variables
#

r"""
Usage: foo
   or: foo --input=FILE
Options: --input [env: INPUT]
"""

$ prog
{}

$ INPUT=bar prog
{"--input": "bar"}

r"""
Usage: foo --input=FILE
Options: --input [env: INPUT]
"""

$ prog
"user-error"

$ INPUT=bar prog
{"--input": "bar"}

r"""
Usage: foo --input=FILE...
Options: --input [env: INPUT]
"""

$ prog
"user-error"

$ INPUT="foo bar" prog
{"--input": ["foo bar"]}

#
# Environment variables - issue #22
#

r"""
Usage: foo
   or: foo (--input=FILE)
Options: --input [env: INPUT]
"""

$ prog
{}

$ INPUT=bar prog
{"--input": "bar"}

r"""
Usage: foo
   or: foo (--input=FILE) | (--input=FILE --output=BAR)
Options: --input  [env: INPUT]
         --output [env: OUTPUT]
"""

$ prog
{}

$ INPUT=bar OUTPUT=qux prog
{"--input": "bar", "--output": "qux"}

$ OUTPUT=qux prog --input=bar
{"--input": "bar", "--output": "qux"}

#
# Ensure comma separated values provided on the command line or through the
# environment are *NOT* parsed into arrays. This has been identified as flaw
# in design an is subject to removal from neodoc. This change excludes default
# value declarations ([default: a,b,c]) since it's in the developers control
# and comma-parsing can be skipped by quoting ([default: 'a,b,c'])
#
# Refer #16
#

r"""
Usage: foo --input=FILE...
Options: --input [env: INPUT]
"""

$ INPUT="foo,bar" prog
{"--input": ["foo,bar"]}

$ prog --input "foo bar"
{"--input": ["foo bar"]}

$ prog --input "foo,bar"
{"--input": ["foo,bar"]}

$ prog --input foo,bar
{"--input": ["foo,bar"]}

#
# Test stdin (-)
#

r"""
Usage: foo -
"""

$ prog
{}

$ prog -
{"-": true}

r"""
Usage: foo [-]
"""

$ prog
{}

$ prog -
{"-": true}

#
# Test EOA (--)
#

r"""
Usage: foo -- ARGS...
"""

$ prog
{"--": []}

$ prog --
{"--": []}

$ prog -- --foo bar
{"--": ["--foo", "bar"]}

r"""
Usage: foo --
"""

$ prog
{"--": []}

$ prog --
{"--": []}

$ prog -- --foo bar
{"--": ["--foo", "bar"]}

#
# Validate error messages
#

r"""
Usage: foo -f ARG
Options: -f, --foo ARG
"""

# Missing option-arguments are fatal errors, no pardon:

$ prog -f
"option requires argument: -f"

r"""
Usage: foo [-f ARG]
Options: -f, --foo ARG
"""

$ prog -f
"option requires argument: -f"

r"""
Usage: foo [[-f ARG]]
Options: -f, --foo ARG
"""

$ prog -f
"option requires argument: -f"

r"""
Usage: foo [[-bf=ARG]]
Options: -f, --foo ARG
"""

$ prog -f
"option requires argument: -f"

r"""
Usage: foo (-bf=ARG)
Options: -f, --foo ARG
"""

$ prog -f
"option requires argument: -f"

r"""
usage: git (([-f ARG]))
Options: -f, --foo ARG
"""

$ prog -f
"option requires argument: -f"

r"""
usage: git (([-f ARG]))
   or: git -f ARG
Options: -f, --foo ARG
"""

$ prog -f
"option requires argument: -f"

r"""
usage: git (([-f ARG | -b]))
Options: -f, --foo ARG
"""

$ prog -f
"option requires argument: -f"

r"""
usage: git (([-b | -f ARG]))
Options: -f, --foo ARG
"""

$ prog -f
"option requires argument: -f"

r"""
usage: git (([-bf ARG]))
Options: -f, --foo ARG
"""

$ prog -f
"option requires argument: -f"

r"""
usage: git (([-b ARG | -f ARG]))
Options: -f, --foo ARG
"""

$ prog --foo
"option requires argument: --foo"

r"""
usage: git (([-b | -f ARG]))
Options: -f, --foo ARG
"""

$ prog
{}

r"""
usage: git (([-b | -f[=ARG]]))
Options: -f, --foo ARG
"""

$ prog -f
{"-f": true, "--foo": true}

r"""
Usage: prog mine (set|remove)
"""

$ prog mine
"missing set"

#
# Given an option-argument to a flag is a fatal error, no pardon:
#

r"""
usage: git -b
options: -b, --boo
"""

$ prog -b=FOO
"option takes no argument: -b"

$ prog --boo=FOO
"option takes no argument: --boo"

r"""
usage: git -f <foo>
"""

$ prog/s -fb
"unknown option -b"

#
# Command and positional errors:
#

r"""Usage: git <command> -f"""
$ prog
"missing <command>"

r"""Usage: git COMMAND -f"""
$ prog
"missing COMMAND"

r"""Usage: git pull -f"""
$ prog
"missing pull"

r"""
Usage: git <command> -f
   or: git <foo> -f
"""
$ prog
""

# Ambigous errors
r"""
Usage: foo remote
       foo
"""

$ prog --fooo
"unknown option --fooo"

r"""
Usage: foo
       foo remote
"""

$ prog --fooo
"unknown option --fooo"

#
# This usage section parse must fail until #23 comes to fruition.
#

r"""
usage: git remote [-v | --verbose]
       git remote [--[no-]tags]
"""

$ prog
"spec-error"

#
# Check proper option subsumption takes place
#

r"""
Usage: foo [-f=FOO] [-b=BAR]
"""

$ prog -foobar
{"-f": "oobar"}

$ prog -f=oobar
{"-f": "oobar"}

$ prog -fb=oobar
{"-f": "b=oobar"}

r"""
Usage: foo [-f[=FOO]] [-b=BAR]
"""

$ prog -foobar
{"-f": "oobar"}

$ prog -fboobar
{"-f": "boobar"}

r"""
Usage: foo [-f=FOO] [-b=BAR]
Options: -f, --foo=FOO
"""

$ prog --foobar
{"-f": "bar", "--foo": "bar"}

$ prog --foo=bar
{"-f": "bar", "--foo": "bar"}

$ prog --foobar QUX
"unknown command QUX"

$ prog --foo=bar QUX
"unknown command QUX"

r"""
Usage: foo [-f[=FOO]] [-b=BAR]
Options: -f, --foo[=FOO]
"""

$ prog --foobar
{"-f": "bar", "--foo": "bar"}

$ prog --foo=bar
{"-f": "bar", "--foo": "bar"}

$ prog --foobar QUX
"unknown command QUX"

$ prog --foo=bar QUX
"unknown command QUX"

#
# Proper value parsing
#

r"""
Usage: foo <command> [-f ARG] [-b ARG]
"""

$ prog/s 123foo -f123foo -b=123foo
{"<command>": "123foo",
 "-f": "123foo", "-b": "123foo"}

#
# Fix issue where defaults are not applied.
# E.g. `-p` would not yield 5000 if `-x` was given.
#

r"""
# Usage: foo ([-p PORT] -x [-f=d])
Options: -p PORT [default: 5000]
"""

$ prog -x
{"-x": true, "-p": 5000}

r"""
Usage: foo [-p PORT] -x ([-f=d])
Options: -p PORT [default: 5000]
"""

$ prog -x -p 100 -f 100
{"-x": true, "-p": 100, "-f": 100}

r"""
Usage: foo [-p PORT] -x... ([-f=d])
Options: -p PORT [default: 5000]
"""

$ prog -x -p 100 -x -f 100 -x
{"-x": 3, "-p": 100, "-f": 100}

$ prog -p 100 -f 100
{"-p": 100, "-f": 100}

$ prog -p 100 -f 100 -x
{"-x": 1, "-p": 100, "-f": 100}

r"""
Usage: foo [-a FOO] [-b BAR] [-c QUX]
options: -b BAR [default: 100]
"""

$ prog/s
{"-b": 100}

$ prog/s -c 300
{"-b": 100, "-c": 300}

$ prog/s -a 200
{"-a": 200, "-b": 100}

$ prog/s -c 200
{"-b": 100, "-c": 200}

r"""
Usage: foo [-a FOO] [-b BAR] [-c QUX]
options: -a FOO [default: 100]
"""

$ prog/s
{"-a": 100}

$ prog/s -c 300
{"-a": 100, "-c": 300}

$ prog/s -b 200
{"-b": 200, "-a": 100}

$ prog/s -c 200
{"-a": 100, "-c": 200}

r"""
Usage: foo [-a FOO] [-b BAR] [-c QUX]
options: -a FOO [default: 100]
         -b BAR [default: 200]
         -c QUX [default: 300]
"""

$ prog/s
{"-a": 100, "-b": 200, "-c": 300}

$ prog/s -c 400
{"-a": 100, "-b": 200, "-c": 400}

r"""
Usage: foo [-a FOO] | [[-a FOO] [-b BAR]]
options: -a FOO [default: 100]
         -b BAR [default: 200]
"""

$ prog/s -a 2000
{"-a": 2000, "-b": 200}

$ prog/s -b 2000
{"-a": 100, "-b": 2000}

$ prog/s -a 1000 -b 2000
{"-a": 1000, "-b": 2000}

r"""
Usage: foo [[-a FOO] | [[-a FOO] [-b BAR]]]
options: -a FOO [default: 100]
         -b BAR [default: 200]
"""

$ prog/s -a 2000
{"-a": 2000, "-b": 200}

$ prog/s -b 2000
{"-a": 100, "-b": 2000}

$ prog/s -a 1000 -b 2000
{"-a": 1000, "-b": 2000}

r"""
Usage: foo [[-a FOO] | [[-a FOO] [-b BAR]]]...
options: -a FOO [default: 100]
         -b BAR [default: 200]
"""

$ prog/s -a 2000
{"-a": [2000], "-b": [200]}

$ prog/s -b 2000
{"-a": [100], "-b": [2000]}

$ prog/s -a 1000 -b 2000
{"-a": [1000], "-b": [2000]}

# Fix issue #31
# The syntax is still fairly constrained - but on purpose in order to keep
# the `--` the definitive EOA marker. The reason `[--] ARGS` is allowed, despite
# not being "correct" is for compatibilites sake.

r"""
Usage: foo [--] <pathspec>...
"""

$ prog
{"--": []}

r"""
Usage: foo [[--] ARGS]
"""

$ prog
{"--": []}

# Fix issue #33
# Lift "incoherent specification" restriction for missing option-argument if
# argument is declared optional.

r"""
Usage: foo -f
Options: -f[=ARG]
"""

$ prog
{}

$ prog -f
{"-f": true}

$ prog -fabc
{"-f": "abc"}


r"""
Usage: foo --foo
Options: --foo[=ARG]
"""

$ prog
{}

$ prog --foo
{"--foo": true}

$ prog --foo=abc
{"--foo": "abc"}

# Fix issue #34
# Option parser trips up if `--` is preseent in description RHS

r"""
usage: foo [options]
options:
    --foo This is foo. Not applicable if --qux is given.
    --bar This is bar.
"""

$ prog --bar
{"--bar": true}

r"""
usage: foo [options] [<command>]
options:
    <command> this is command.
    --foo     This is foo. Not applicable if --qux is given.
    --bar     This is bar.
"""

$ prog --bar run
{"--bar": true, "<command>": "run"}

$ prog --bar
{"--bar": true}

r"""
usage: foo [options] <command>
options:
    --foo     This is foo. Not applicable if --qux is given.
    <command> this is command.
    --bar     This is bar.
"""

$ prog --bar run
{"--bar": true, "<command>": "run"}

# ARG and '...' should be ignored since they are on different lines:
r"""
usage: foo [options]
options:
   --foo
       ARG
       ...
   -q
       ARG
       ...
"""

$ prog --foo
{"--foo": true}

$ prog -q
{"-q": true}

# -f and --foo should *NOT* be associated w/o a comma if on different lines
r"""
usage: foo [options]
options:
   -f
   --foo
"""

$ prog -f
{"-f": true}

$ prog --foo
{"--foo": true}

# -f and --foo *SHOULD* be associated via a comma if on different lines
r"""
usage: foo [options]
options:
   -f,
   --foo
"""

$ prog -f
{"-f": true, "--foo": true}

$ prog --foo
{"-f": true, "--foo": true}

#
# issue #46 - repeating option arguments w/o repeating the option
#

r"""
usage: foo [--foo BAR...]
"""

$ prog/s --foo 1 2 3
{"--foo": [1, 2, 3]}

$ prog/s --foo 1 2 --foo 3
{"--foo": [1, 2, 3]}

$ prog/s --foo 1 --foo 2 3
{"--foo": [1, 2, 3]}

r"""
usage: foo [--foo [BAR...]]
"""

$ prog/s --foo 1 2 3
{"--foo": [1, 2, 3]}

$ prog/s --foo 1 2 --foo 3
{"--foo": [1, 2, 3]}

$ prog/s --foo 1 --foo 2 3
{"--foo": [1, 2, 3]}

r"""
usage: foo [--foo [BAR...]...]
"""

$ prog/s --foo 1 2 3
{"--foo": [1, 2, 3]}

$ prog/s --foo 1 2 --foo 3
{"--foo": [1, 2, 3]}

$ prog/s --foo 1 --foo 2 3
{"--foo": [1, 2, 3]}

r"""
usage: foo [--foo [BAR]...]
"""

$ prog/s --foo 1 2 3
{"--foo": [1, 2, 3]}

$ prog/s --foo 1 2 --foo 3
{"--foo": [1, 2, 3]}

$ prog/s --foo 1 --foo 2 3
{"--foo": [1, 2, 3]}

r"""
usage: foo [--foo [BAR]...]...
"""

$ prog/s --foo 1 2 3
{"--foo": [1, 2, 3]}

$ prog/s --foo 1 2 --foo 3
{"--foo": [1, 2, 3]}

$ prog/s --foo 1 --foo 2 3
{"--foo": [1, 2, 3]}

r"""
usage: foo [--foo BAR]...
"""

$ prog/s --foo 1 2 3
"unknown command 2"

r"""
usage: foo [--foo BAR]...
"""

$ prog/s --foo 1 --foo 2 --foo 3
{"--foo": [1, 2, 3]}

#
# issue #55
#

r"""
usage: prog --foo [BAR]
options: --foo BAR
"""

$ prog --foo foo
{"--foo": "foo"}

$ prog --foo
{"--foo": true}

r"""
usage: prog --foo (BAR)
options: --foo BAR
"""

$ prog --foo foo
{"--foo": "foo"}

$ prog --foo
"option requires argument: --foo"

r"""
usage: prog --foo [BAR]...
options: --foo BAR
"""

$ prog --foo foo --foo bar
{"--foo": ["foo", "bar"]}

$ prog --foo foo bar
{"--foo": ["foo", "bar"]}

r"""
usage: prog -f [BAR]
options: -f BAR
"""

$ prog -f foo
{"-f": "foo"}

r"""
usage: prog -f [BAR]...
options: -f BAR
"""

$ prog -f foo -f bar
{"-f": ["foo", "bar"]}

$ prog -f foo bar
{"-f": ["foo", "bar"]}

r"""
usage: prog -of [BAR]
options: -f BAR
"""

$ prog -f foo
{"-f": "foo"}

r"""
usage: prog -of [BAR]...
options: -f BAR
"""

$ prog -f foo -f bar
{"-f": ["foo", "bar"]}

$ prog -f foo bar
{"-f": ["foo", "bar"]}


# do not repeat if arg is explicitly bound

r"""
usage: prog --foo=<bar>... cool
"""

$ prog --foo=bar cool
{"--foo": ["bar"], "cool": true}

r"""
usage: prog -f=<bar>... cool
"""

$ prog -f=bar cool
{"-f": ["bar"], "cool": true}

#
# Disallow varying program names - issue #62
#

r"""
usage: foo
   or: bar
"""

$ prog
"spec-error"

r"""
usage: foo
       bar
"""

$ prog
"spec-error"

#
# Required flags - issue #61
#

r"""
usage: prog --foo
"""

$ prog/r
"missing --foo"

r"""
usage: prog --foo --bar
"""

$ prog/r
"missing --foo"

r"""
usage: prog (--foo --bar) --qux
"""

# only reports error of first group
$ prog/r
"missing --foo"

$ prog/r --yikes
"unknown option --yikes"

#
# Free positionals
#

r"""
usage: prog <BAR>... --foo
"""

$ prog/l --foo a b c
{"--foo": true, "<BAR>": [ "a", "b", "c"]}

r"""
usage: prog <BAR> <QUX> --foo
"""

$ prog/l --foo a b
{"--foo": true, "<BAR>": "a", "<QUX>": "b"}

$ prog/l a --foo b
{"--foo": true, "<BAR>": "a", "<QUX>": "b"}

$ prog/l a b --foo
{"--foo": true, "<BAR>": "a", "<QUX>": "b"}

r"""
usage: prog go foo
"""

$ prog/l foo go
"expected go, but got foo"

r"""
usage: prog [foo] bar [qux]
"""

$ prog/l bar
{"bar": true}

r"""
usage: prog (a) b
"""

$ prog/l b a
"expected a, but got b"

$ prog/l a b
{"a": true, "b": true}

r"""
usage: prog go... foo
"""

$ prog/l foo go
"expected go..., but got foo"

r"""
usage: prog [foo...]... bar... [qux]
"""

$ prog/l bar
{"bar": 1}

r"""
usage: prog (a...)... b...
"""

$ prog/l b a
"expected a..., but got b"

$ prog/l a b
{"a": 1, "b": 1}

r"""
usage: prog move --speed=<kn>...
"""

$ prog/l --speed 100
"missing move"

r"""
usage: prog move [--speed=<kn>...]...
"""

$ prog/l --speed=100 move --speed 200 300
{"move": true, "--speed": [100, 200, 300]}

# Ensure optional positionals are retried still in lax-placement mode
r"""
usage: prog [foo] -a
"""

$ prog/l -a foo
{"-a": true, "foo": true}

r"""
usage: prog [foo] -a [bar]
"""

$ prog/l -a foo bar
{"-a": true, "foo": true, "bar": true}

r"""
usage: prog [foo] -a [bar]
"""

$ prog/l foo -a bar
{"-a": true, "foo": true, "bar": true}

r"""
usage: prog [foo] -a [bar]
"""

$ prog/l foo bar -a
{"-a": true, "foo": true, "bar": true}

r"""
usage: prog [foo] -a [bar]
"""

$ prog/l bar foo -a
"unexpected command foo"

r"""
usage: prog [foo] -a [bar]
"""

$ prog/l bar -a foo
"unexpected command foo"

r"""
usage: prog [foo] -a [bar]
"""

$ prog/l bar foo
"unexpected command foo"

r"""
usage: prog [foo] -a [bar]
"""

$ prog/l -a bar foo
"unexpected command foo"

r"""
usage: prog [foo] -a [bar]
"""

$ prog/l -a bar
{"-a": true, "bar": true}

$ prog/l bar -a
{"-a": true, "bar": true}

r"""
usage: prog [foo] -a bar
"""

$ prog/l bar -a
{"-a": true, "bar": true}

$ prog/l -a bar
{"-a": true, "bar": true}

#
# Issue 77
#

r"""
usage: fbit configure [<client-id> <client-secret>
                      |--clientid=<client-id> --clientsecret=<client-secret>
                      ]
"""

$ prog configure --clientid 123
"missing --clientsecret=<client-secret>"

$ prog configure --clientid 123 --foo
"unknown option --foo"

$ prog configure --clientid 123 --clientsecret
"option requires argument: --clientsecret"


r"""
usage: fbit configure ([<client-id> <client-secret>]
                      |[--clientid=<client-id> --clientsecret=<client-secret>])
"""

$ prog configure --clientid 123
"missing --clientsecret=<client-secret>"

$ prog configure --clientid 123 --foo
"unknown option --foo"

$ prog configure --clientid 123 --clientsecret
"option requires argument: --clientsecret"

#
# repeatable options (#32)
#

r"""
usage: prog (-c | -d) foo -e
"""

$ prog/R -c -c -c foo -e -e
{"-c": 3, "foo": true, "-e": 2}

r"""
usage: prog -a -b -c
"""

$ prog/R -a -a -b -c -b -a -c -b -a -c -bbbb -aaa -c
{"-a": 7, "-b": 7, "-c": 4}

r"""
usage: prog -e (-a | -b) -c
"""

$ prog/R -a -a -b
"unexpected option -b"

$ prog/R -a -a
{"-a": 2}

$ prog/R -c -c -a -a
{"-a": 2, "-c": 2}

r"""
usage: prog [-c FOO] -a
"""

$ prog/Rs -c foo -a -c bar -c qux
{"-c": ["foo", "bar", "qux"], "-a": true}


r"""
usage: prog [-c FOO] run -a
"""

$ prog/lRs -c foo -a run -c bar -c qux
{"-c": ["foo", "bar", "qux"], "-a": true, "run": true}

$ prog/lRs -c foo -a -c bar -c qux run
{"-c": ["foo", "bar", "qux"], "-a": true, "run": true}

$ prog/lRs -c foo -a -c bar run -c qux
{"-c": ["foo", "bar", "qux"], "-a": true, "run": true}

$ prog/lRs -c foo run -a -c bar -c qux
{"-c": ["foo", "bar", "qux"], "-a": true, "run": true}

$ prog/lRs run -c foo -a -c bar -c qux
{"-c": ["foo", "bar", "qux"], "-a": true, "run": true}

r"""
usage: prog [-a] f -b
"""

$ prog/lR -b -a -a f
{"f": true, "-a": 2, "-b": true}

$ prog/lR -a -b -a f
{"f": true, "-a": 2, "-b": true}

$ prog/lR -a -b -a -a f
{"f": true, "-a": 3, "-b": true}

$ prog/lR -b -a -b f
{"f": true, "-a": true, "-b": 2}

r"""
usage: prog [-a] f -b=ARG
options:
    -bARG  asdf [default: 100]
"""

$ prog/lR -a -a f
"missing -bARG"

$ prog/lR -b=20 -a -a f
{"f": true, "-a": 2, "-b": 20}

r"""
usage: prog [-a] f [-b=ARG]
options:
    -bARG  asdf [default: 100]
"""

$ prog/lR -a -a f
{"-a": 2, "f": true}

r"""
usage: prog [[-a]... [-b] [-d=ARG] [-c]] foo
options:
  -d=ARG  [default: 1000]
"""

$ prog -c -a -b -a foo
{"foo": true, "-a": 2, "-b": true, "-c": true, "-d": 1000}

# "fixed" groups should be able to move within the boundaries of other
# surrounding "fixed" groups
#

r"""
usage: p -x [-y <command>] -z
"""

$ prog/l -z -x
{"-x": true, "-z": true}

$ prog/l -z -x -y foo
{"-x": true, "-z": true, "-y": true, "<command>": "foo"}

$ prog/l -z -x foo -y
{"-x": true, "-z": true, "-y": true, "<command>": "foo"}

# note: this test confirms termination when caching

r"""
usage: p [[<args>]...]
"""

$ prog/rRslup
{"<args>": []}

r"""
usage: p
"""

$ prog/u -a -b -c
{"?": ["-a", "-b", "-c"]}

r"""
usage: p -b
"""

$ prog/u -a -b -c
{"-b": true, "?": ["-a", "-c"]}

r"""
usage: p [-b [-a]]
"""

$ prog/u -a -b -c
{"-b": true, "-a": true, "?": ["-c"]}

$ prog/ur -a -b -c
{"-b": true, "-a": true, "?": ["-c"]}

$ prog/lur -a -b -c
{"-b": true, "-a": true, "?": ["-c"]}

$ prog/lurR -a -b -c
{"-b": true, "-a": true, "?": ["-c"]}

r"""
usage: p [-b [-a]] foo
"""

$ prog/u -acb foo
{"-a": true, "?": ["-cb"], "foo": true}

$ prog/lu foo -acb
{"-a": true, "?": ["-cb"], "foo": true}

$ prog/lu foo -acb bar
"unknown command bar"

$ prog/lu foo -acb bar --foo
"unknown command bar"

$ prog/lu foo -acb bar --foo qux
"unknown command bar"

$ prog/lu foo -acb -- qux
{"-a": true, "?": ["-cb"], "foo": true, "--": ["qux"]}

$ prog/lu foo -acb -- qux bar
{"-a": true, "?": ["-cb"], "foo": true, "--": ["qux", "bar"]}

$ prog/lu foo -acb bar - qux
"unknown command bar"

# This is a tricky one: '-a' is known and gets consumed, but since it does not
# take an argument it leaves a '-cb' on the input. Then, '-c' is not known, so
# we consume the entire token: '-cb', resulting in a missing '-b'.
$ prog/lur foo -acb
"missing -b"

$ prog/lur foo -ac -b
{"-a": true, "-b": true, "?": ["-c"], "foo": true}

# ensure '--' is treated correctly when inserted implicitly due to the /u flag
# (opts.allowUnknown), while also being mentioned explicitly. '--' always
# collects into an array, so a duplicate _should_ not matter.
r"""
usage: p [-b [-a]] foo -- args...
"""

$ prog/lu foo -acb -- qux
{"-a": true, "?": ["-cb"], "foo": true, "--": ["qux"]}

$ prog/lu foo -acb -- qux bar
{"-a": true, "?": ["-cb"], "foo": true, "--": ["qux", "bar"]}

r"""
usage: p ship new <name>...
"""

$ prog/luRrps ship new --fast foo
{"<name>": ["foo"], "new": true, "ship": true, "?": ["--fast"]}

# fix error message on adjacent positionals
r"""
usage: p <a> <b>
"""

$ prog
"missing <a>"

################################################################################
# negated options
################################################################################
# TODO, check:
#       * verify `lookupValidDescription` impl in ExpandOptions.purs (for sopts)
#       * verify behavior when option takes argument
#       * verify `bloatDescAliases` in Reduce.purs (should we only do this if
#         `options.implicitNegatives`?)
#       * `findDescriptions` should also look for negative matches (Annotate.purs)
#       * parsing `--no-` and `+` should fail if option does not allow it (when
#         (implicit) feature is turned off)
#       * In `collect` (Reduce.purs), we must inject all negative variants to
#         build the composite key... or remove all negatives and represent only
#         in terms of positives...
#
# Changes:
#       * Incompat FFI change to UsageLayout

r"""
usage: p -f...
options:
 -f, +f  ...foo
"""

$ prog +f -f +f +f -f -f
{"-f": 2}

$ prog +f -f +f +f
{"-f": 0}

r"""
usage: p -f
options:
 -f, +f
"""

$ prog -f
{"-f": true}

$ prog +f
{"-f": false}

$ prog/R -f +f
{"-f": false}

$ prog/R -f +f -f -f +f
{"-f": false}

r"""
usage: p --foo
"""

$ prog --no-foo
"unknown option --no-foo"

$ prog/n --no-foo
{"--foo": false}

r"""
usage: p -f
options:
 -f, --[no-]foo, +f
"""

$ prog +f
{"-f": false, "--foo": false}

$ prog/R -f +f
{"-f": false, "--foo": false}

$ prog --no-foo
{"-f": false, "--foo": false}

r"""
usage: p [options]
options:
 -f, --[no-]foo
"""

$ prog/n +f +f
"unexpected option +f"

$ prog +f
"unknown option +f"

$ prog/n +f
{"-f": false, "--foo": false}

$ prog/R -f +f
"unknown option +f"

$ prog/Rn -f +f
{"-f": false, "--foo": false}

$ prog --no-foo
{"-f": false, "--foo": false}

r"""
usage: p --[no-]foo=ARG
"""

$ prog --no-foo=123
"option takes no argument: --no-foo"

$ prog --foo=123
{"--foo": 123}

$ prog --no-foo
{"--foo": false}

r"""
usage: p --[no-]foo[=ARG]
"""

$ prog --no-foo=123
"option takes no argument: --no-foo"

$ prog --foo=123
{"--foo": 123}

$ prog --foo
{"--foo": true}

$ prog --no-foo
{"--foo": false}

r"""
usage: p --no-foo=ARG
"""

$ prog --no-foo=123
"option takes no argument: --no-foo"

$ prog --foo=123
{"--foo": 123}

$ prog --no-foo
{"--foo": false}

r"""
usage: p [options]

options:
    --[no-]foo=ARG
"""

$ prog --no-foo=123
"option takes no argument: --no-foo"

$ prog --foo=123
{"--foo": 123}

$ prog --no-foo
{"--foo": false}

r"""
usage: p [options]

options:
    --no-foo=ARG
"""

$ prog --no-foo=123
"option takes no argument: --no-foo"

$ prog --foo=123
{"--foo": 123}

$ prog --no-foo
{"--foo": false}
